<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《算法4》-习题2.1</title>
      <link href="/2025/07/25/%E7%AE%97%E6%B3%954/%E3%80%8A%E7%AE%97%E6%B3%954%E3%80%8B-%E4%B9%A0%E9%A2%982.1/"/>
      <url>/2025/07/25/%E7%AE%97%E6%B3%954/%E3%80%8A%E7%AE%97%E6%B3%954%E3%80%8B-%E4%B9%A0%E9%A2%982.1/</url>
      
        <content type="html"><![CDATA[<h3 id="习题-2-1"><a href="#习题-2-1" class="headerlink" title="习题 2.1"></a>习题 2.1</h3><blockquote><p>不包括基础题和实验题</p></blockquote><h4 id="13-纸牌排序"><a href="#13-纸牌排序" class="headerlink" title="13 纸牌排序"></a>13 纸牌排序</h4><p>利用插入排序的思想，从头至尾遍历卡牌，每次翻开邻近的两张卡牌，每当位置在前的卡牌大于位置在后的卡牌时，两卡牌进行交换。每次交换后，继续翻开本次交换位置向前进一次的一对卡牌（前方无卡牌时不再需要）。</p><h4 id="14-出列排序"><a href="#14-出列排序" class="headerlink" title="14 出列排序"></a>14 出列排序</h4><p>两种操作:</p><ul><li>交换牌堆最上面两张牌</li><li>将牌顶的牌放到最下面<br>只需当牌顶第一张牌小于第二章时进行交换。反之，将第一张牌塞入最底下即可。</li></ul><h4 id="15-昂贵的交换"><a href="#15-昂贵的交换" class="headerlink" title="15 昂贵的交换"></a>15 昂贵的交换</h4><p>题目说将两个货箱交换位置很困难，比较发货时间很容易。说明需要交换次数较少的排序算法，根据书籍前面所讲，<strong>选择排序</strong>正好符合。</p><h4 id="16-验证"><a href="#16-验证" class="headerlink" title="16 验证"></a>16 验证</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(Comparable[] a)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(a); <span class="comment">// 排序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存地址</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            tmp[i] = a[i].hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打乱排序后的数组 a</span></span><br><span class="line">        exch(a, <span class="number">0</span>, n - <span class="number">1</span>); <span class="comment">// 交换首尾对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进行第二次排序</span></span><br><span class="line">        sort(a);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!isSorted(a)) &#123; <span class="comment">// 判断是否有序</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 判断是否对象被修改</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i] != a[i].hashCode()) &#123; <span class="comment">// 地址不等，说明对象被修改（直接修改对象的值进行排序）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="17-动画"><a href="#17-动画" class="headerlink" title="17 动画"></a>17 动画</h4><p>以选择排序为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">double</span>[] a)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;               <span class="comment">// 数组长度</span></span><br><span class="line">        StdDraw.setCanvasSize(<span class="number">500</span>, <span class="number">300</span>); <span class="comment">// 设置画布参数</span></span><br><span class="line">        StdDraw.setXscale(<span class="number">0</span>, N);</span><br><span class="line">        StdDraw.setYscale(<span class="number">0</span>, <span class="number">200</span>);</span><br><span class="line">        StdDraw.setPenRadius(<span class="number">0.04</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;  <span class="comment">// 将a[i]和a[i+1..N]中最小的元素交换</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;                 <span class="comment">// 最小元素的索引</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; N; j++)</span><br><span class="line">                <span class="keyword">if</span> (less(a[j], a[min])) min = j;</span><br><span class="line">            exch(a, i, min);</span><br><span class="line">            <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0.2</span>, y = <span class="number">0.3</span>;</span><br><span class="line">            StdDraw.clear(); <span class="comment">// 清空绘图</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">double</span> v : a) &#123; <span class="comment">// 绘图代码</span></span><br><span class="line">                StdDraw.line(x, y, x, y + v * <span class="number">10</span>);</span><br><span class="line">                x += <span class="number">0.78</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            StdDraw.pause(<span class="number">1000</span>); <span class="comment">// 暂停1000ms</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="18-可视轨迹"><a href="#18-可视轨迹" class="headerlink" title="18 可视轨迹"></a>18 可视轨迹</h4><p>以选择排序为例</p><p>修改绘图代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                StdDraw.setPenColor((j == i || j == min) ? StdDraw.RED : StdDraw.BLACK);</span><br><span class="line">                StdDraw.line(x, y, x, y + a[j] * <span class="number">10</span>);</span><br><span class="line">                x += <span class="number">0.78</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h4 id="19-希尔排序的最坏情况"><a href="#19-希尔排序的最坏情况" class="headerlink" title="19 希尔排序的最坏情况"></a>19 希尔排序的最坏情况</h4><p>由于希尔排序是插入排序的改进版，因此会继承插入排序的特点，当数组是逆序时，进行正序排序比较的次数会是最多，所以序列因是</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[100, 99, 98, ......, 3, 2, 1]</span><br></pre></td></tr></table></figure><h4 id="20-希尔排序最好的情况"><a href="#20-希尔排序最好的情况" class="headerlink" title="20 希尔排序最好的情况"></a>20 希尔排序最好的情况</h4><p>最好的情况便是已经排序好的序列。对排序好的序列进行希尔排序时，只需要比较，无须移动对象。</p><h4 id="21-可比较的交易"><a href="#21-可比较的交易" class="headerlink" title="21 可比较的交易"></a>21 可比较的交易</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transaction</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Transaction&gt;&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Transaction</span><span class="params">(<span class="type">double</span> amount, <span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.amount = amount;</span><br><span class="line">        <span class="built_in">this</span>.year = year;</span><br><span class="line">        <span class="built_in">this</span>.month = month;</span><br><span class="line">        <span class="built_in">this</span>.day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> amount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> year, month, day; <span class="comment">// 交易时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Transaction that)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.amount &gt; that.amount) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.amount &lt; that.amount) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交易金额相等时 时间逆序</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.year != that.year) <span class="keyword">return</span> <span class="built_in">this</span>.year - that.year;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.month != that.month) <span class="keyword">return</span> <span class="built_in">this</span>.month - that.month;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.day != that.day) <span class="keyword">return</span> <span class="built_in">this</span>.day - that.day;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 时间与金额都相同</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 《算法4》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 习题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《算法4》 -- 第二章 排序</title>
      <link href="/2025/07/17/%E7%AE%97%E6%B3%954/%E3%80%8A%E7%AE%97%E6%B3%954%E3%80%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/07/17/%E7%AE%97%E6%B3%954/%E3%80%8A%E7%AE%97%E6%B3%954%E3%80%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>排序就是将一组对象按照某种逻辑顺序重新排列的过程。</p><h3 id="学习排序的三大意义"><a href="#学习排序的三大意义" class="headerlink" title="学习排序的三大意义"></a>学习排序的三大意义</h3><ul><li>对排序算法的分析将有助于你全面理解本书中比较算法性能的方法；</li><li>类似的技术也能有效解决其他类型的问题；</li><li>排序算法常常是我们解决其他问题的第一步。</li></ul><h3 id="排序算法模板类"><a href="#排序算法模板类" class="headerlink" title="排序算法模板类"></a>排序算法模板类</h3><p><strong>Example类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span> </span><br><span class="line">    &#123;  <span class="comment">/* 请见算法2.1、算法2.2、算法2.3、算法2.4、算法2.5或算法2.7*/</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(Comparable v, Comparable w)</span> </span><br><span class="line">    &#123;  <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;  &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span><br><span class="line">    &#123;  <span class="type">Comparable</span> <span class="variable">t</span> <span class="operator">=</span> a[i]; a[i] = a[j]; a[j] = t;  &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Comparable[] a)</span> </span><br><span class="line">    &#123;  <span class="comment">// 在单行中打印数组 </span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) </span><br><span class="line">        StdOut.print(a[i] + <span class="string">&quot; &quot;</span>); </span><br><span class="line">      StdOut.println(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSorted</span><span class="params">(Comparable[] a)</span> </span><br><span class="line">    &#123;  <span class="comment">// 测试数组元素是否有序 </span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) </span><br><span class="line">        <span class="keyword">if</span> (less(a[i], a[i-<span class="number">1</span>]))  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;  <span class="comment">// 从标准输入读取字符串，将它们排序并输出 </span></span><br><span class="line">      String[] a = In.readStrings();  </span><br><span class="line">      sort(a); </span><br><span class="line">      <span class="keyword">assert</span> <span class="title function_">isSorted</span><span class="params">(a)</span></span><br><span class="line">      show(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序算法的分类"><a href="#排序算法的分类" class="headerlink" title="排序算法的分类"></a>排序算法的分类</h3><ul><li>函数调用所需的栈和固定数目的实例变量之外无需额外内存的<strong>原地排序算法</strong></li><li>需要额外内存空间来存储另一份数组副本的其他排序算法</li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>步骤：首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。</p><p>特点：</p><ul><li><code>运行时间与输入无关</code> ：无论输入是有序还是无序，运行时间不变。</li><li><code>数据移动最少</code>：在数据移动次数与数据长度相同。</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Selection</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span></span><br><span class="line">    &#123;  <span class="comment">// 将a[]按升序排列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;               <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;  <span class="comment">// 将a[i]和a[i+1..N]中最小的元素交换</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;                 <span class="comment">// 最小元素的索引</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; N; j++)</span><br><span class="line">                <span class="keyword">if</span> (less(a[j], a[min])) min = j;</span><br><span class="line">            exch(a, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// less()、exch()、isSorted()和main()方法见“排序算法类模板”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>步骤：为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。</p><p>插入排序对于实际应用中常见的某些类型的非随机数组很有效。所以：<strong>插入排序的运行时间与输入相关</strong>。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Insertion</span> </span><br><span class="line">&#123;  </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span> </span><br><span class="line">   &#123;  <span class="comment">// 将a[]按升序排列 </span></span><br><span class="line">      <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;              </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) </span><br><span class="line">      &#123;   <span class="comment">// 将 a[i] 插入到 a[i-1]、a[i-2]、a[i-3]...之中 </span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j-<span class="number">1</span>]); j--)</span><br><span class="line">            exch(a, j, j-<span class="number">1</span>); </span><br><span class="line">      &#125; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">// less()、exch()、isSorted()和main()方法见“排序算法类模板” </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>部分有序数组</strong>：<br>定义：数组中倒置（比如：在EXA中，E-A、X-A就是倒置）的数量小于数组大小的某个倍数，该数组就是部分有序的。<br>以下是几种典型的部分有序数组：</p><ul><li>数组中每个元素距离它的最终位置都不远；</li><li>一个有序的大数组接一个小数组；</li><li>数组中只有几个元素的位置不正确。</li></ul><p>插入排序对于部分有序的数组十分高效，也很适合小规模数组。</p><h3 id="排序算法之间的比较"><a href="#排序算法之间的比较" class="headerlink" title="排序算法之间的比较"></a>排序算法之间的比较</h3><p>比较步骤：</p><ul><li>实现并调试它们；</li><li>分析它们的基本性质；</li><li>对它们的相对性能作出猜想；</li><li>用实验验证我们的猜想。</li></ul><p><strong>计时程序代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortCompare</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">time</span><span class="params">(String alg, Comparable[] a)</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">Stopwatch</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stopwatch</span>(); </span><br><span class="line">        <span class="keyword">if</span> (alg.equals(<span class="string">&quot;Insertion&quot;</span>)) Insertion.sort(a); </span><br><span class="line">        <span class="keyword">if</span> (alg.equals(<span class="string">&quot;Selection&quot;</span>)) Selection.sort(a); </span><br><span class="line">        <span class="keyword">if</span> (alg.equals(<span class="string">&quot;Shell&quot;</span>))     Shell.sort(a); </span><br><span class="line">        <span class="keyword">if</span> (alg.equals(<span class="string">&quot;Merge&quot;</span>))     Merge.sort(a); </span><br><span class="line">        <span class="keyword">if</span> (alg.equals(<span class="string">&quot;Quick&quot;</span>))     Quick.sort(a); </span><br><span class="line">        <span class="keyword">if</span> (alg.equals(<span class="string">&quot;Heap&quot;</span>))      Heap.sort(a); </span><br><span class="line">        <span class="keyword">return</span> timer.elapsedTime(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">timeRandomInput</span><span class="params">(String alg, <span class="type">int</span> N, <span class="type">int</span> T)</span> </span><br><span class="line">    &#123;  <span class="comment">// 使用算法alg将T个长度为N的数组排序  </span></span><br><span class="line">        <span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0.0</span>; </span><br><span class="line">        Double[] a = <span class="keyword">new</span> <span class="title class_">Double</span>[N]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; t &lt; T; t++) </span><br><span class="line">        &#123;  <span class="comment">// 进行一次测试（生成一个数组并排序) </span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) </span><br><span class="line">              a[i] = StdRandom.uniform(); </span><br><span class="line">          total += time(alg, a); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> total; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">String</span> <span class="variable">alg1</span> <span class="operator">=</span> args[<span class="number">0</span>]; </span><br><span class="line">        <span class="type">String</span> <span class="variable">alg2</span> <span class="operator">=</span> args[<span class="number">1</span>]; </span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">2</span>]); <span class="comment">// 数据规模</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">T</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">3</span>]); <span class="comment">// 重复实验次数</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">t1</span> <span class="operator">=</span> timeRandomInput(alg1, N, T); <span class="comment">// 算法1的总时间 </span></span><br><span class="line">        <span class="type">double</span> <span class="variable">t2</span> <span class="operator">=</span> timeRandomInput(alg2, N, T); <span class="comment">// 算法2的总时间 </span></span><br><span class="line">        StdOut.printf(“For %d random Doubles\n    %s is”, N, alg1); </span><br><span class="line">        StdOut.printf(“ %<span class="number">.1f</span> times faster than %s\n”, t2/t1, alg2); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是基于插入排序的快速的排序算法。为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。思想是使数组中任意<strong>间隔</strong>为<strong>h</strong>的元素都是<strong>有序</strong>的。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shell</span> </span><br><span class="line">&#123;   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span> </span><br><span class="line">   &#123;  <span class="comment">// 将a[]按升序排列 </span></span><br><span class="line">      <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length; </span><br><span class="line">      <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>; </span><br><span class="line">      <span class="keyword">while</span> (h &lt; N/<span class="number">3</span>) h = <span class="number">3</span>*h + <span class="number">1</span>; <span class="comment">// 1, 4, 13, 40, 121, 364, 1093, ... </span></span><br><span class="line">      <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) </span><br><span class="line">      &#123;  <span class="comment">// 将数组变为h有序 </span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h; i &lt; N; i++) </span><br><span class="line">          &#123;  <span class="comment">// 将a[i]插入到a[i-h], a[i-2*h], a[i-3*h]... 之中 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j -= h) </span><br><span class="line">               exch(a, j, j-h); </span><br><span class="line">          &#125; </span><br><span class="line">          h = h/<span class="number">3</span>; </span><br><span class="line">      &#125; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// less()、exch()、isSorted()和main()方法见“排序算法类模板”</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 《算法4》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 1.两数之和</title>
      <link href="/2025/07/15/LeetCode/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2025/07/15/LeetCode/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h4><p><a href="https://leetcode.cn/problems/two-sum/">传送门</a></p><p>1、通过两个for循环暴力枚举</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target == nums[i] + nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2、排序 <code>nums</code>，使其呈增序，再利用双指针寻找符合 <code>target</code> 的答案。（执行时间超越百分百）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; tmp;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; a, <span class="type">const</span> <span class="keyword">auto</span>&amp; b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.first == b.first) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> s = tmp[l].first + tmp[r].first;</span><br><span class="line">            <span class="keyword">if</span>(s == target) <span class="keyword">return</span> &#123;tmp[l].second, tmp[r].second&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s &lt; target) l++;</span><br><span class="line">            <span class="keyword">else</span> r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
